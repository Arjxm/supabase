---
id: 'authorization'
title: 'Realtime Authorization'
description: 'Authorization for Supabase Realtime'
sidebar_label: 'Authorization'
---

<Admonition type="note">

Realtime Channels Authorization is in preview. Please [contact us]() to enable this feature for your project.

</Admonition>

<Admonition type="note">

The [Typescript client library](https://www.npmjs.com/package/@supabase/realtime-js/v/2.10.0-next.6) is still under heavy development and as such is under the `next` version to ensure a better developer experience.

</Admonition>

Realtime provides a system to set authorization per Channel and per Channel feature (Broadcast and Presence).

In this section we detail how to set up Channel authorization using RLS policies.

## How it works

We use tables in the `realtime` schema to allow you to write RLS policies that will determine the access your users have to your Channel and features within a Channel.

The validation itself is done on connect per each user, meaning that for each WebSocket connection we generate the policy of your user based on:

- the RLS policies you provided with their connection context which will include JWT
- Headers set on connect and
- the Channel the user is trying to connect against

Increased RLS complexity can impact database performance and user connection time, leading to higher connection latency and decreased user join rates.

## Helper functions

We've included a helper function to facilitate building policies, making it easier to access user connection context.

### realtime.channel_name

Returns name of the channel to which the user is connecting against.

```sql
CREATE POLICY "authenticated users can view all profiles"
ON "realtime"."channels"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (
  realtime.channel_name = 'room_1'
);
```

## Creating Channels

<Admonition type="note">

If you don't create a channel, we assume you don't want RLS enabled on it.

</Admonition>

As previously stated, tables in the Realtime schema now represent your Channels.

These are not automatically created upon connection; you must perform this action yourself.

Once a Channel is created, it will be subject to RLS policy checks.

<Admonition type="note">

Whenever you use this feature we advice you to setup your RLS policies first otherwise you won't be able to test your code properly.

</Admonition>

### Admin created Channels

Using your `service_role` token you can call either our REST endpoint or use a client library to create a Channel.

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
  <TabPanel id="js" label="JavaScript">

    ```js
    // If you used service_role to initialize client library
    await supabase.realtime.createChannel(name)
    ```

  </TabPanel>
  <TabPanel id="bash" label="Bash">

    ```bash
    curl -v -X POST 'https://<project_ref>.supabase.co/realtime/v1/api/channels'\
    --header 'apikey: <service_role>'\
    --header 'Authorization: Bearer <access_token>' \
    --data-raw '{ "name": "<channel name>" }'
    ```

  </TabPanel>
</Tabs>

### User created Channels

Users can create Channels by creating an RLS policy for `INSERT` on the `realtime.channels` table.

Utilize your `anon_token` and set the `Authorization` header with the bearer token to verify if a user can create a Channel.

If permitted, the Channel will be created.

```sql
CREATE POLICY "authenticated can create channel"
ON "realtime"."channels"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (TRUE);
```

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
  <TabPanel id="js" label="JavaScript">

    ```js
    supabase.realtime.setAuth(token)
    await supabase.realtime.createChannel(name)
    ```

  </TabPanel>
  <TabPanel id="bash" label="Bash">

    ```bash
    curl -X POST 'https://<project_ref>.supabase.co/realtime/v1/api/channels'\
     --header 'apikey: <anon_token>'\
     --header 'Authorization: Bearer <access_token>' \
     --header 'Content-Type: application/json'\
     --data-raw '{ "name": "<channel name>" }'
    ```

  </TabPanel>
</Tabs>

## Authorizing Channels

Channels serve as our WebSocket representation, and here, we restrict joining capabilities by preventing WebSocket connections and terminating such connections.

### Example schema

Using the following schema for our examples below.

```sql
CREATE TABLE public.profiles (
  email text NOT NULL,
  user_id uuid REFERENCES auth.users (id)
);
CREATE TABLE public.rooms_users (
  name text REFERENCES realtime.channels (name),
  user_id uuid REFERENCES auth.users (id),
  created_at timestamptz DEFAULT CURRENT_TIMESTAMP
);

// Trigger to populate profiles table
CREATE OR REPLACE FUNCTION insert_user () RETURNS TRIGGER AS
$$
  BEGIN
    INSERT INTO public.profiles (user_id, email) VALUES (NEW.id, NEW.email); RETURN NEW;
  END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER "on_new_auth_create_profile"
AFTER INSERT ON auth.users FOR EACH ROW
EXECUTE FUNCTION insert_user ();

GRANT EXECUTE ON FUNCTION insert_user () TO supabase_auth_admin;
```

### Allow Channel join

To allow access we'll write an RLS policy for `SELECT` and determine which users are able to connect.

You can implement the following policy to grant access to the Channel exclusively to users listed in the relationship table `public.rooms_users`.

```sql
CREATE POLICY "authenticated users can view all profiles"
ON "realtime"."channels"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (
EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
  )
);
```

## Authorize Broadcast read and write

Broadcast is represented by a new table called `broadcasts` under the `realtime` schema that will be associated with a Channel via id and which will be automatically created for you.

### Allow Broadcast read

To grant users permission to read Broadcast messages on a Channel, you must create a policy for `SELECT` operations on `realtime.broadcasts`.

```sql
CREATE POLICY "authenticated user can receive in room"
ON "realtime"."broadcasts"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
  )
);
```

### Allow Broadcast write

Similarly to allow sending Broadcast messages you'll need to set a policy for `UPDATE` in `realtime.broadcasts`.

```sql
CREATE POLICY "authenticated user can broadcast in room"
ON "realtime"."broadcasts"
AS PERMISSIVE FOR UPDATE
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
  )
);
```

## Authorize Presence read and write

Similar to setting up a Broadcast, you can establish the same for Presence. This allows you to specify whether users can read Presence changes or write Presece updates.

### Allow Presence read

Again, here we use a policy for `SELECT` for `realtime.presences`.

```sql
CREATE POLICY "authenticated user can listen to changes in room"
ON "realtime"."presences"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
  )
);
```

### Allow Presence write

To update the Presence status for a user we need to create a policy for `UPDATE` on `realtime.presences`.

```sql
CREATE POLICY "authenticated user can register presence in room"
ON "realtime"."presences"
AS PERMISSIVE FOR UPDATE
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
  )
);
```

## Managing Channels

Now that you can create Channels, you can also manage them.

Utilizing your `service_role` token enables you to perform all operations, bypassing RLS.

Alternatively, you can create RLS policies to authorize your users to manage only certain Channels.

### List Channels

List Channels a user has access to.

Results are filtered with the `SELECT` policy on the `realtime.channels` tables.

```sql
-- Authenticated user would access and be able to list all channels
CREATE POLICY "authenticated users can view all profiles"
ON "realtime"."channels"
AS PERMISSIVE FOR SELECT
TO authenticated
USING ( true )
```

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
  <TabPanel id="js" label="JavaScript">

    ```js
    supabase.realtime.listChannels()
    ```

  </TabPanel>
  <TabPanel id="bash" label="Bash">

    ```bash
    curl 'https://<project_ref>.supabase.co/realtime/v1/api/channels'\
     --header 'apikey: <anon_token>'\
     --header 'Authorization: Bearer <access_token>' \
     --header 'Content-Type: application/json'\
    ```

  </TabPanel>
</Tabs>

### Delete Channel

Users can also delete Channels based on the `DELETE` policy on the `realtime.channels` table.

```sql
-- Authenticated user can delete all channels
CREATE POLICY authenticated_all_channels_delete
ON realtime.channels FOR DELETE
TO authenticated
USING ( true );
```

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
  <TabPanel id="js" label="JavaScript">

    ```js
    supabase.realtime.deleteChannel(name)
    ```

  </TabPanel>
  <TabPanel id="bash" label="Bash">

    ```bash
    curl -X DELETE 'https://<project_ref>.supabase.co/realtime/v1/api/channels'\
     --header 'apikey: <anon_token>'\
     --header 'Authorization: Bearer <access_token>' \
     --header 'Content-Type: application/json'\
    ```

  </TabPanel>
</Tabs>

### Update Channel

Users can update Channel names. Channel names are unique so users will receive unique index errors if a Channel already exists.

```sql
-- authenticated users can update channel name
CREATE POLICY authenticated_all_channels_update
ON realtime.channels FOR UPDATE
TO authenticated
USING ( true )
```

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
  <TabPanel id="js" label="JavaScript">

    ```js
    supabase.realtime.updateChannel(old_name, new_name)
    ```

  </TabPanel>
  <TabPanel id="bash" label="Bash">

    ```bash
    curl -X PATCH 'https://<project_ref>.supabase.co/realtime/v1/api/channels/<old_name>'\
     --header 'apikey: <anon_token>'\
     --header 'Authorization: Bearer <access_token>' \
     --header 'Content-Type: application/json'\
     --data-raw '{ "name": "<new name>" }'
    ```

  </TabPanel>
</Tabs>

## Avoid usage with Postgres Changes

If the Channel is created the policies on `realtime.channels` will influence the Channels you use to receive updates for Postgres Changes.

We recommend not creating a Channel before subscribing when useing Postgres Changes.

In this way, Realtime Channl authorization is backwards compatible with your production application.

## Changing RLS policies

When you change an RLS policy these changes are picked up when a user connects to a Channel.

When a user connects, Realtime queries your database and generates a representation of the permissions for a user for a Channel.

Permissions are cached for the duration of the connection so we don't have to query your database for each Channel message.

RLS policies are re-checked when access tokens are updated on the Channel. Our client libraries default to updating the access token every 30 seconds.

If a user Channel permissions have been updated these changes will be picked up when the access token is sent over the Channel from the client.

If a new access token is never received on the Channel users will be disconnected when the JWT expires.

Make sure to expire your JWTs frequently.
